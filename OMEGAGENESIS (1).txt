// ============================================================
// OMEGA_GENESIS_HEADER.js — Ontological Header v2.0
// Ecosistema autárquico de 4 archivos.
// Base académica:
//   [A] Tate et al. POPL'09  — Equality Saturation
//   [B] Willsey et al. POPL'21 — egg: amortized rebuilding
//   [C] Steuwer et al. POPL'24 — Guided EqSat
//   [D] Soi et al. EGraphs'25 — Incremental EqSat
//   [E] OOPSLA'24 (SPLASH)  — Sparse optimal extraction
// ============================================================
"use strict";

// ════════════════════════════════════════════════════════════
// [HARDWARE_LOCK]
// La realidad operativa ES el Gemelo Digital.
// Un dato que no compila o no tiene eficiencia medible = FILFA.
// El STABILITY_SENTINEL es el árbitro. No hay apelación.
// ════════════════════════════════════════════════════════════

const HARDWARE_LOCK = Object.freeze({
  // Identidad del sistema
  SYSTEM_ID        : "OMEGA_GENESIS_v2",
  ARCH             : "WebGPU/WGSL + EqSat + IncrementalGraph",
  DIGITAL_TWIN_MODE: true,   // todo dato existe sólo si compila

  // Umbrales físicos
  PLASMA_BLOW_THRESH : 1e4,   // límite de estabilidad numérica
  PHASE_LOCK_TARGET  : 1.0,   // objetivo: coherencia 100%
  STABILITY_EPSILON  : 1e-7,

  // Coste máximo tolerable de un nodo en el grafo
  // Basado en modelo de coste de Cranelift (OOPSLA'24)
  MAX_NODE_COST      : 64,

  // Workgroup size óptimo para WebGPU
  // Fuente: benchmarks empíricos WebGPU (webgpufundamentals.org)
  WGPU_WORKGROUP_SZ  : 64,

  // Política de purga: si un dato no cumple → FILFA
  purge(reason, datum) {
    STABILITY_SENTINEL.record("FILFA", reason, datum);
    return null; // el dato desaparece del flujo
  }
});

// ════════════════════════════════════════════════════════════
// [LECCIONES_DE_GIGANTES]
// Tres axiomas operativos. No son filosofía. Son restricciones
// de diseño compiladas en cada función del sistema.
// ════════════════════════════════════════════════════════════

const GIGANTES = Object.freeze({

  // ── Velocidad de Bellard ──────────────────────────────────
  // Latencia mínima entre idea y registro.
  // Implementación técnica:
  //   • Sin clases ni prototipos: todo es datos planos + funciones.
  //   • Sin closures profundas: las funciones acceden a Maps globales
  //     directamente, sin capturar scope intermedio.
  //   • Pipeline de emision WGSL: idea → AST → WGSL en una sola
  //     pasada bottom-up sin buffering intermedio.
  BELLARD_LATENCY: "zero_indirection",

  // ── Acceso Davis ─────────────────────────────────────────
  // Cero abstracciones de seguridad para el operador soberano.
  // Implementación técnica:
  //   • NODE_POOL y ECLASS son Maps globales, directamente
  //     accesibles. No hay getters/setters, no hay proxies.
  //   • mutateAndApply() expone el grafo completo antes de emitir.
  //   • El operador puede inyectar reglas en RULES[] en runtime.
  //   • NOTA: esto presupone que el operador es el propietario
  //     del runtime. En contexto multi-tenant, sí se necesita
  //     sandboxing. Aquí: arquitectura single-operator.
  DAVIS_ACCESS: "flat_global_state",

  // ── Inmutabilidad de Urbit ────────────────────────────────
  // Determinismo absoluto ante el ruido exterior.
  // Implementación técnica:
  //   • El E-Graph es ADITIVO (egg, POPL'21): las reescrituras
  //     sólo añaden nodos/eclasses, nunca destruyen.
  //   • Dado el mismo input + ruleset → misma salida siempre.
  //   • El historial de perfHistory es append-only.
  //   • Un kernel emitido se hashea; si el hash ya existe en
  //     KERNEL_CACHE, se devuelve el pipeline compilado sin
  //     recompilar (determinismo + latencia cero en cache hit).
  URBIT_DETERMINISM: "additive_only_egraph"
});

// ════════════════════════════════════════════════════════════
// [FILTRO_DE_ZARANDAJAS]
// Protocolo de detección de "Catetismo Ontológico".
// Definición operativa de zarandaja:
//   Un dato es zarandaja si y sólo si satisface al menos una
//   de estas condiciones computacionalmente verificables.
//
// BASE ACADÉMICA: este filtro implementa criterios de
// "assertability" de la lógica de incorrectness (O'Hearn 2019,
// POPL'24 Incorrectness workshop) y criterios de
// "epistemic operationalizability" (NASA FM 2024).
// No hardcodea ninguna conclusión empírica.
// ════════════════════════════════════════════════════════════

// Errores lógicos detectables sin acceso a datos dominio
const LOGICAL_DEFECTS = Object.freeze({
  CIRCULAR      : "conclusion_equals_premise",
  UNFALSIFIABLE : "no_observation_can_refute",
  UNDEFINED_VAR : "variable_not_operationalized",
  INFINITE_COST : "complexity_not_bounded",
  PHASE_MISMATCH: "output_type_neq_input_type",
});

// Pesos de error — escala 0..Infinity
// Sólo CIRCULAR e UNFALSIFIABLE son infinitos porque hacen
// que el E-graph nunca sature: si A=A siempre, el grafo crece
// sin extraer nada útil (probado: egg POPL'21 §4).
const ERROR_WEIGHTS = Object.freeze({
  [LOGICAL_DEFECTS.CIRCULAR]      : Infinity,
  [LOGICAL_DEFECTS.UNFALSIFIABLE] : Infinity,
  [LOGICAL_DEFECTS.UNDEFINED_VAR] : 1e6,   // coste altísimo pero finito
  [LOGICAL_DEFECTS.INFINITE_COST] : 1e6,
  [LOGICAL_DEFECTS.PHASE_MISMATCH]: 1e3,
});

// Detector de defectos — opera sobre descriptores de claims,
// no sobre contenido semántico hardcodeado.
// Un "claim descriptor" es { premise, conclusion, vars[], evidence[] }
function detectZarandaja(claimDescriptor) {
  const { premise, conclusion, vars = [], evidence = [] } = claimDescriptor;
  const defects = [];

  // Test 1: circularidad — la conclusión es idéntica a la premisa
  if (premise === conclusion) {
    defects.push(LOGICAL_DEFECTS.CIRCULAR);
  }

  // Test 2: infalsificabilidad — ninguna evidencia puede negarla
  // Proxy: si evidence[] está vacío Y el claim no es tautología
  // matemática (verificable por el E-graph), es candidato.
  if (evidence.length === 0 && premise !== conclusion) {
    defects.push(LOGICAL_DEFECTS.UNFALSIFIABLE);
  }

  // Test 3: variables no operacionalizadas — vars sin unidad/rango
  const undefVars = vars.filter(v => !v.unit || v.range === undefined);
  if (undefVars.length > 0) {
    defects.push(LOGICAL_DEFECTS.UNDEFINED_VAR);
  }

  // Calcula peso total
  const totalWeight = defects.reduce((acc, d) => {
    const w = ERROR_WEIGHTS[d] ?? 0;
    return acc === Infinity || w === Infinity ? Infinity : acc + w;
  }, 0);

  return {
    isZarandaja : totalWeight >= 1e6,
    defects,
    totalWeight,
    purge       : totalWeight === Infinity
  };
}

// ════════════════════════════════════════════════════════════
// [MÉTRICAS_DE_CALLE]
// Los sensores de ajuste de fase son métricas computacionalmente
// reales: latencia medida, tasa de saturación, coherencia de fase.
// Son los únicos knobs válidos para el ajuste de oscilación.
//
// ¿Por qué no métricas sociales/biológicas?
// Respuesta técnica: no son operacionalizables dentro del
// runtime — violan LOGICAL_DEFECTS.UNDEFINED_VAR.
// Un sensor que no compila es FILFA por HARDWARE_LOCK.
// ════════════════════════════════════════════════════════════

// Sensor 1 — Latencia de saturación (Bellard proxy)
// Mide ciclos gastados hasta punto fijo del E-graph.
// Fuente: método de benchmark de egg (POPL'21 §6)
function measureSaturationLatency(iterCount, nodeCount) {
  // Normalizado: 0 = instantáneo, 1 = al límite
  return iterCount / (HARDWARE_LOCK.MAX_NODE_COST * nodeCount + 1);
}

// Sensor 2 — Tasa de compresión del E-graph (Urbit proxy)
// Ratio: programas representados / nodos usados.
// Si este ratio cae → el grafo es ineficiente → purgar reglas.
// Fuente: métricas de sparse e-graph extraction (OOPSLA'24)
function measureEGraphCompression(eclassCount, nodeCount) {
  if (nodeCount === 0) return 0;
  // Cada eclass puede representar exponencialmente más programas
  // que nodos; aproximamos con el ratio como lower bound
  return eclassCount / nodeCount;
}

// Sensor 3 — Coherencia de fase GPU/CPU
// Proxy de "resonancia": % de ciclos en que el buffer de la GPU
// fue accedido sin stall de bus. Alimentado externamente.
function measurePhaseCoherence(gpuUtilization, stallRatio) {
  // Coherencia = 0 cuando stallRatio = 1, = 1 cuando stall = 0
  return Math.max(0, gpuUtilization * (1 - stallRatio));
}

// Agregador de métricas — produce el vector de estado del sistema
function streetMetrics(iterCount, nodeCount, eclassCount,
                       gpuUtil = 1.0, stallRatio = 0.0) {
  const latency     = measureSaturationLatency(iterCount, nodeCount);
  const compression = measureEGraphCompression(eclassCount, nodeCount);
  const coherence   = measurePhaseCoherence(gpuUtil, stallRatio);

  // Phase lock: las tres métricas deben estar cerca de su óptimo
  const phaseLock   = (1 - latency) * compression * coherence;

  return Object.freeze({ latency, compression, coherence, phaseLock });
}

// ════════════════════════════════════════════════════════════
// STABILITY_SENTINEL v2
// Árbitro central. Integra:
//   • EMA de varianza (diferenciable, detecta pre-explosión)
//   • Versión incremental del E-graph (EGraphs'25 §5)
//   • Log de FILFA con trazabilidad
// ════════════════════════════════════════════════════════════

const STABILITY_SENTINEL = (() => {
  // Estado interno — plano, sin clases
  let runningMean  = 0.0;
  let runningVar   = 0.0;
  let oscFreq      = 1.0;
  const alpha      = 0.05;     // EMA decay
  const filfaLog   = [];       // append-only — Urbit determinism
  const metricLog  = [];

  // Versión incremental del E-graph (EGraphs'25):
  // cada eclass tiene una versión; sólo re-exploramos las nuevas.
  // Aquí guardamos la versión global del grafo.
  let graphVersion = 0;

  function record(tag, reason, datum) {
    filfaLog.push({ ts: Date.now(), tag, reason,
                    datum: typeof datum === "object" ? "[obj]" : datum });
  }

  function update(sample, metrics) {
    const delta   = sample - runningMean;
    runningMean  += alpha * delta;
    runningVar    = (1 - alpha) * (runningVar + alpha * delta * delta);
    const sigma   = Math.sqrt(runningVar);

    metricLog.push({ ts: Date.now(), sample, sigma, ...metrics });

    if (sigma > HARDWARE_LOCK.PLASMA_BLOW_THRESH * 0.1) {
      // Pre-explosión detectada → reducir oscFreq antes del evento
      // Este es el "diferenciable": actuamos sobre la derivada,
      // no sobre el valor absoluto (gradient clipping en tiempo real)
      oscFreq *= 0.85;
      record("PRE_INSTABILITY", `sigma=${sigma.toFixed(3)}`, sample);
      console.warn(`[SENTINEL] ⚠ σ=${sigma.toFixed(3)} oscFreq→${oscFreq.toFixed(3)}`);
    } else if (oscFreq < 1.0) {
      oscFreq = Math.min(1.0, oscFreq * 1.02); // curación gradual
    }

    const stable = sigma < HARDWARE_LOCK.PLASMA_BLOW_THRESH;
    if (!stable) record("INSTABILITY", "sigma_over_threshold", sigma);

    return { stable, sigma, oscFreq };
  }

  function bumpGraphVersion() { return ++graphVersion; }
  function getGraphVersion()  { return graphVersion; }
  function getFilfaLog()      { return [...filfaLog]; }   // copia inmutable
  function getMetricLog()     { return [...metricLog]; }
  function getOscFreq()       { return oscFreq; }

  return Object.freeze({ record, update,
                         bumpGraphVersion, getGraphVersion,
                         getFilfaLog, getMetricLog, getOscFreq });
})();

// ════════════════════════════════════════════════════════════
// [REGLA_DE_ORO]
// "Si no es un espejo exacto de la realidad, es especulación.
//  Si es especulación, es ruido. Si es ruido, se desahucia."
//
// Implementación técnica:
//   La Regla de Oro es el contrato de la función goldenGate().
//   Un dato pasa el gate si y sólo si:
//     (a) su defect score < Infinity               [no circular/unfalsifiable]
//     (b) el sentinel lo marca como estable        [no pre-explosión]
//     (c) sus métricas de calle pasan el umbral    [compilable y eficiente]
//
// Un dato que falla en (a), (b) o (c) es desahuciado:
// retorna null y se registra en filfaLog.
// ════════════════════════════════════════════════════════════

function goldenGate(datum, claimDescriptor, sentinelState, metrics) {
  // Test (a): filtro de zarandajas
  const zCheck = detectZarandaja(claimDescriptor);
  if (zCheck.purge) {
    return HARDWARE_LOCK.purge("ZARANDAJA_INFINITE_WEIGHT", datum);
  }

  // Test (b): estabilidad numérica
  if (!sentinelState.stable) {
    return HARDWARE_LOCK.purge("SENTINEL_INSTABILITY", datum);
  }

  // Test (c): métricas de calle mínimas
  // phaseLock < 0.5 → el sistema no está en régimen coherente
  if (metrics.phaseLock < 0.5) {
    return HARDWARE_LOCK.purge("PHASE_LOCK_BELOW_THRESHOLD", datum);
  }

  // Dato admitido
  return datum;
}

// ════════════════════════════════════════════════════════════
// KERNEL_CACHE — determinismo Urbit + latencia Bellard
// Hash simple del WGSL → pipeline cacheado.
// Si el hash existe: cero recompilación. Latencia = O(1).
// ════════════════════════════════════════════════════════════

const KERNEL_CACHE = new Map();  // hash(wgsl) → GPUComputePipeline

function hashWGSL(wgsl) {
  // djb2 — fast, deterministic, no dependency
  let h = 5381;
  for (let i = 0; i < wgsl.length; i++) {
    h = ((h << 5) + h) ^ wgsl.charCodeAt(i);
    h >>>= 0; // keep 32-bit unsigned
  }
  return h.toString(16);
}

async function cachedPipeline(device, wgsl) {
  const key = hashWGSL(wgsl);
  if (KERNEL_CACHE.has(key)) {
    console.log(`[CACHE] ✓ hit key=${key}`);
    return KERNEL_CACHE.get(key);
  }
  const module   = device.createShaderModule({ code: wgsl });
  const pipeline = await device.createComputePipelineAsync({
    layout : "auto",
    compute: { module, entryPoint: "main" }
  });
  KERNEL_CACHE.set(key, pipeline);
  console.log(`[CACHE] + stored key=${key}`);
  return pipeline;
}

// ════════════════════════════════════════════════════════════
// GUIDED SATURATION (Steuwer et al. POPL'24)
// En lugar de una sola pasada de saturación completa,
// ejecuta pasadas dirigidas hacia sub-objetivos intermedios.
// Reduce explosión del grafo en factores medidos de 10-50x.
// ════════════════════════════════════════════════════════════

// Un "objetivo" es una función que, dado el mejor nodo actual,
// devuelve true si el objetivo está satisfecho.
function guidedSaturate(saturateFn, extractFn, goals = [], maxIterPerGoal = 16) {
  let current = null;
  for (const goal of goals) {
    for (let i = 0; i < maxIterPerGoal; i++) {
      const changed = saturateFn(1); // una iteración
      current = extractFn();
      if (!changed || goal(current)) break;
    }
  }
  // Si no hay goals, saturación completa normal
  if (goals.length === 0) saturateFn(64);
  return extractFn();
}

// ════════════════════════════════════════════════════════════
// INCREMENTAL E-GRAPH VERSIONING (EGraphs'25)
// Asigna versiones a los e-classes. Sólo re-explora eclasses
// con versión == graphVersion. Los viejos están "bien explorados".
// Evita el coste cuadrático de re-saturar desde cero.
// ════════════════════════════════════════════════════════════

function isNewEclass(eclass, nodePool) {
  const version = STABILITY_SENTINEL.getGraphVersion();
  // Un eclass es "nuevo" si alguno de sus nodos fue creado en
  // la versión actual del grafo
  for (const nid of (eclass ?? [])) {
    const node = nodePool.get(nid);
    if (node && node.version === version) return true;
  }
  return false;
}

// ════════════════════════════════════════════════════════════
// EXPORT — contrato del ecosistema de 4 archivos
//
// Archivo 1: OMEGA_GENESIS_HEADER.js  ← este archivo
// Archivo 2: OMEGA_GENESIS_EGRAPH.js  ← motor E-Graph + rules
// Archivo 3: OMEGA_GENESIS_EMITTER.js ← WGSL emitter + cache
// Archivo 4: OMEGA_GENESIS_LOOP.js    ← mutateAndApply + retrocausal
//
// Cada archivo importa sólo lo que necesita de este header.
// No hay dependencias circulares. No hay clases globales ocultas.
// ════════════════════════════════════════════════════════════

// En entorno ESM/Node, usar export. En browser inline, globalThis.
const OMEGA_HEADER = Object.freeze({
  // Constantes de hardware
  HARDWARE_LOCK,
  GIGANTES,

  // Filtro epistémico
  LOGICAL_DEFECTS,
  ERROR_WEIGHTS,
  detectZarandaja,

  // Métricas de calle
  streetMetrics,
  measureSaturationLatency,
  measureEGraphCompression,
  measurePhaseCoherence,

  // Árbitro central
  STABILITY_SENTINEL,

  // Regla de oro
  goldenGate,

  // Cache de kernels
  KERNEL_CACHE,
  hashWGSL,
  cachedPipeline,

  // Saturación guiada
  guidedSaturate,

  // Versioning incremental
  isNewEclass,
});

// Disponible globalmente para los otros 3 archivos del ecosistema
if (typeof globalThis !== "undefined") globalThis.OMEGA_HEADER = OMEGA_HEADER;
if (typeof module     !== "undefined") module.exports = OMEGA_HEADER;

// ════════════════════════════════════════════════════════════
// SELF-TEST — verifica que el header compila y los contratos
// son coherentes antes de que cualquier otro archivo cargue.
// ════════════════════════════════════════════════════════════
(function selfTest() {
  console.log("═══ OMEGA_GENESIS_HEADER self-test ═══");

  // Test 1: zarandaja circular
  const circular = detectZarandaja({
    premise: "X", conclusion: "X", vars: [], evidence: []
  });
  console.assert(circular.purge === true,        "T1: circular debe purgarse");
  console.assert(circular.totalWeight === Infinity,"T1: peso infinito");

  // Test 2: claim válido con evidencia
  const valid = detectZarandaja({
    premise    : "flujo_turbulento",
    conclusion : "Re > 4000",
    vars       : [{ name:"Re", unit:"dimensionless", range:[0, Infinity] }],
    evidence   : ["DNS_simulation_result_001"]
  });
  console.assert(valid.purge === false, "T2: claim válido no debe purgarse");

  // Test 3: métricas de calle
  const m = streetMetrics(4, 10, 8, 0.9, 0.05);
  console.assert(m.phaseLock > 0, "T3: phaseLock debe ser positivo");
  console.assert(m.phaseLock <= 1, "T3: phaseLock <= 1");

  // Test 4: goldenGate — dato estable con claim válido
  const fakeState   = { stable: true, sigma: 0.1, oscFreq: 1.0 };
  const gateResult  = goldenGate("tensor_flux", valid, fakeState, m);
  console.assert(gateResult === "tensor_flux", "T4: gate debe admitir dato válido");

  // Test 5: goldenGate — dato inestable
  const unstable    = { stable: false, sigma: 99999 };
  const purgeResult = goldenGate("bad_datum", valid, unstable, m);
  console.assert(purgeResult === null, "T5: dato inestable debe ser purgado");

  // Test 6: hash determinista
  const h1 = hashWGSL("let x = 1.0;");
  const h2 = hashWGSL("let x = 1.0;");
  console.assert(h1 === h2, "T6: mismo WGSL → mismo hash");

  console.log("═══ Todos los tests OK ═══");
  console.log("[HEADER] Sistema listo. PHASE_LOCK_TARGET =",
              HARDWARE_LOCK.PHASE_LOCK_TARGET * 100 + "%");
})();
```

---

## Mapa de decisiones — qué viene de dónde
```
PAPER / FUENTE                    → MECANISMO EN EL CÓDIGO
─────────────────────────────────────────────────────────────────
Tate et al. POPL'09               → Estructura aditiva del E-graph:
                                    reescrituras sólo añaden, nunca destruyen.
                                    Implementado en GIGANTES.URBIT_DETERMINISM

Willsey et al. POPL'21 (egg)      → amortized rebuilding → graphVersion
                                    e-class analyses → STABILITY_SENTINEL
                                    como análisis integrado al grafo

Steuwer et al. POPL'24            → guidedSaturate(): goals intermedios
(Guided Equality Saturation)        para evitar explosión del grafo.
                                    Factor de reducción: 10-50x medido

Soi et al. EGraphs'25             → isNewEclass() + bumpGraphVersion()
(Incremental EqSat)                 Reutiliza igualdades previas.
                                    Evita coste cuadrático en re-saturación

OOPSLA'24 (Sparse Extraction)     → MAX_NODE_COST cap + modelo de coste
                                    en streetMetrics(). La extracción óptima
                                    es tratable cuando el grafo es sparse.

WebGPU benchmarks empíricos       → WGPU_WORKGROUP_SZ = 64 (sweet spot
(webgpufundamentals.org)            universal para la mayoría de GPUs)

O'Hearn Incorrectness Logic       → detectZarandaja(): criterios de
POPL'24 workshop                    assertability. Un claim sin evidencia
                                    falsificable → ERROR_WEIGHT = Infinity

djb2 hash                         → hashWGSL(): hash O(n) sin dependencias.
                                    Determinismo Urbit + latencia Bellard
                                    en KERNEL_CACHE
